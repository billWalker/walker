% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/walker.R
\name{walker_glm}
\alias{walker_glm}
\title{Fully Bayesian generalized linear regression with time-varying coefficients}
\usage{
walker_glm(formula, data, beta_prior, sigma_prior, init, chains, newdata,
  distribution = "poisson", initial_mode = "kfas", u, mc_sim = 50,
  return_x_reg = FALSE, return_y_rep = TRUE, ...)
}
\arguments{
\item{formula}{An object of class \code{\link[stats]{formula}}. See \code{\link[stats]{lm}} for details.}

\item{data}{An optional data.frame or object coercible to such, as in \code{\link[stats]{lm}}.}

\item{beta_prior}{A matrix with \eqn{k} rows and 2 columns, where first columns defines the 
prior means of the Gaussian priors of the corresponding \eqn{k} regression coefficients, 
and the second column defines the the standard deviations of those prior distributions.}

\item{sigma_prior}{A matrix with \eqn{k + 1} rows and two colums with similar structure as 
\code{beta_prior}, with first row corresponding to the prior of the standard deviation of the 
observation level noise, and rest of the rows define the priors for the standard deviations of 
random walk noise terms. The prior distributions for all sigmas are 
Gaussians truncated to positive real axis. For non-Gaussian models, this should contain only k rows.}

\item{init}{Initial value specification, see \code{\link[rstan]{sampling}}. 
Note that compared to default in \code{rstan}, here the default is a to sample from the priors.}

\item{chains}{Number of Markov chains. Default is 4.}

\item{newdata}{Optional data.frame containing covariates used for prediction. This argument is 
ignored if argument \code{naive} is \code{TRUE}.}

\item{distribution}{Currently only Poisson models are supported.}

\item{initial_mode}{The initial guess of the fitted values on log-scale. 
Defines the Gaussian approximation used in the MCMC.
Either \code{"obs"} (corresponds to log(y+0.1) in Poisson case), 
\code{"glm"} (mode is obtained from time-invariant GLM), \code{"mle"} 
(default; mode is obtained from maximum likelihood estimate of the model), 
or numeric vector (custom guess).}

\item{u}{For Poisson model, a vector of exposures i.e. E(y) = u*exp(x*beta). Defaults to 1.}

\item{mc_sim}{Number of samples used in importance sampling. Default is 50.}

\item{return_x_reg}{If \code{TRUE}, does not perform sampling, but instead returns the matrix of 
predictors after processing the \code{formula}.}

\item{return_y_rep}{If \code{TRUE} (default), \code{walker} also returns the samples from the 
posterior predictive distribution \eqn{p(y_rep | y)}. This argument is ignored if 
argument \code{naive} is \code{TRUE}.}

\item{...}{Further arguments to \code{\link[rstan]{sampling}}.}
}
\value{
A \code{stanfit} object.
}
\description{
Function \code{walker_glm} is a generalization of \code{walker} for non-Gaussian 
models. Compared to \code{walker}, the returned samples are based on Gaussian approximation, 
which can be used for exact analysis by weighting the sample properly. These weights 
are also returned as a part of the \code{stanfit} (they are generated in the 
generated quantities block of Stan model). See details.
}
\details{
The underlying idea of \code{walker_glm} is based on 
Vihola M, Helske J and Franks J (2016), 
"Importance sampling type correction of Markov chain Monte Carlo and exact
approximations", which is available at ArXiv.

This function is not fully tested yet, so please file and issue and/or pull request 
on Github if you encounter problems. The reason there might be problems in some cases 
is the use of global approximation (i.e. start of the MCMC) instead of more accurate 
but slower local approximation (where model is approximated at each iteration). 
However for these restricted models global approximation should be sufficient, 
assuming the the initial estimate of the conditional mode of p(xbeta | y) not too 
far away from the truth. Thus by default \code{walker_glm} first finds the 
maximum likelihood estimates of the standard deviation parameters 
(using \code\link[KFAS]{KFAS}) package, and 
constructs the approximation at that point, before running the Bayesian 
analysis.
}
\examples{
set.seed(123)
n <- 100
x <- rnorm(n, 1, 1)
beta <- cumsum(c(1, rnorm(n - 1, sd = 0.1)))

level <- -1
u <- sample(1:10, size = n, replace = TRUE)
y <- rpois(n, u * exp(level + beta * x))
ts.plot(y)

out <- walker_glm(y ~ x, u = u, beta_prior = cbind(0, c(10, 10)), 
  sigma_prior = cbind(0, c(2, 2)))
print(out, pars = "sigma_b") ## approximate results
library(diagis)
weighted_mean(extract(out, pars = "sigma_b")$sigma_b, 
  extract(out, pars = "weights")$weights)
}
\seealso{
Package \code{diagis} in CRAN, which provides functions for computing weighted 
summary statistics.
}
